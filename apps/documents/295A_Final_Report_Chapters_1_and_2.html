<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>295A_Final_Report_Chapters_1_and_2</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<h1 id="talknshop-conversational-ai-marketplace">TalkNShop:
Conversational AI Marketplace</h1>
<h1 id="section"></h1>
<h1 id="section-1"></h1>
<h1 id="section-2"></h1>
<table style="width:92%;">
<colgroup>
<col style="width: 91%" />
</colgroup>
<tbody>
<tr>
<td><p>By</p>
<p>Puneet Bajaj</p></td>
</tr>
<tr>
<td><p>Rutuja Nemane</p>
<p>Kalpesh Patil</p>
<p>FNU Sameer</p></td>
</tr>
<tr>
<td>May 2026</td>
</tr>
</tbody>
</table>
<h1 id="section-3"></h1>
<h1 id="section-4"></h1>
<table style="width:92%;">
<colgroup>
<col style="width: 91%" />
</colgroup>
<tbody>
<tr>
<td>A Project Report<br />
Presented to<br />
The Faculty of the College of<br />
Engineering</td>
</tr>
<tr>
<td>San Jose State University<br />
In Partial Fulfillment<br />
Of the Requirements for the Degree<br />
<strong>Master of Science in Software Engineering</strong></td>
</tr>
</tbody>
</table>
<h1 id="section-5"></h1>
<h1 id="section-6"></h1>
<h1 id="section-7"></h1>
<h1 id="section-8"></h1>
<h1 id="section-9"></h1>
<h1 id="section-10"></h1>
<h1 id="section-11"></h1>
<h1 id="section-12"></h1>
<table style="width:92%;">
<colgroup>
<col style="width: 91%" />
</colgroup>
<tbody>
<tr>
<td>Copyright © May 2026</td>
</tr>
<tr>
<td style="text-align: left;"><p>Puneet Bajaj</p>
<p>Rutuja Nemane</p>
<p>Kalpesh Patil</p>
<p>FNU Sameer</p></td>
</tr>
<tr>
<td>ALL RIGHTS RESERVED</td>
</tr>
</tbody>
</table>
<h1 id="section-13"></h1>
<table style="width:74%;">
<colgroup>
<col style="width: 74%" />
</colgroup>
<tbody>
<tr>
<td>APPROVED</td>
</tr>
<tr>
<td></td>
</tr>
<tr>
<td>[Advisor’s Name], Project Advisor</td>
</tr>
</tbody>
</table>
<h1 id="section-14"></h1>
<h1 id="section-15"></h1>
<h1 id="section-16"></h1>
<p>ABSTRACT</p>
<p>TalkNShop: Conversational AI Marketplace</p>
<p>By</p>
<p>Puneet Bajaj</p>
<p>Rutuja Nemane</p>
<p>Kalpesh Patil</p>
<p>FNU Sameer</p>
<p>TalknShop is an innovative conversational AI platform that
revolutionizes online shopping by enabling users to search for products
across multiple marketplaces and list items for sale through natural
language chat interactions. The system leverages Large Language Models
(LLMs) via AWS Bedrock, state machine orchestration using LangGraph, and
real-time WebSocket communication to provide an intuitive, multi-modal
shopping experience. This project addresses the fragmentation of
e-commerce marketplaces by creating a unified conversational interface
that supports both buyer and seller workflows, integrating voice, text,
and image inputs to understand user intent and deliver personalized
product recommendations.</p>
<table style="width:92%;">
<colgroup>
<col style="width: 91%" />
</colgroup>
<tbody>
<tr>
<td>Acknowledgments</td>
</tr>
<tr>
<td>The authors are deeply indebted to Professor Vidhya Charan Bhaskar
for her invaluable comments and assistance in the preparation of this
study.</td>
</tr>
</tbody>
</table>
<p><strong>Table of Contents</strong></p>
<p><a href="#section-17">Chapter 1. Project Overview
<span>7</span></a></p>
<p><a href="#introduction">Introduction <span>7</span></a></p>
<p><a href="#_Toc215847398">Proposed Areas of Study and Academic
Contribution <span>7</span></a></p>
<p><a href="#section-24">Current State of the Art <span>8</span></a></p>
<p><a href="#chapter-2.-project-architecture">Chapter 2. Project
Architecture <span>10</span></a></p>
<p><a href="#_Toc215847401">Introduction <span>10</span></a></p>
<p><a href="#_Toc215847402">Architecture Subsystems
<span>10</span></a></p>
<p><strong>List of Figures</strong></p>
<p>Figure 1.1 TalknShop System Architecture Block Diagram 10</p>
<p>Figure 2.1 Buyer Flow State Machine Graph 17</p>
<p>Figure 2.2 Seller Flow State Machine Graph 19</p>
<p><strong>List of Tables</strong></p>
<p>Table 1.1 Comparison of E-Commerce Platforms 13</p>
<p>Table 2.1 Technology Stack by Service 15</p>
<p>Table 2.2 Buyer Flow Node Descriptions 21</p>
<p>Table 2.3 Seller Flow Node Descriptions 23</p>
<p>Table 2.4 Performance Characteristics by Service 23</p>
<h1 id="section-17"></h1>
<h1 id="section-18"></h1>
<h1 id="chapter-1.-project-overview">Chapter 1. Project Overview</h1>
<h2 id="introduction">Introduction</h2>
<p>The e-commerce landscape has become increasingly fragmented, with
consumers needing to navigate multiple marketplaces (eBay, Amazon,
Walmart, Craigslist, Facebook Marketplace) to find the best products or
list items for sale. Each platform has its own interface, search
capabilities, and listing requirements, creating friction in the
shopping experience. Traditional search interfaces require users to
formulate precise queries, navigate complex filters, and manually
compare results across platforms.<br />
<br />
TalknShop addresses these challenges by introducing a conversational AI
platform that unifies the shopping experience across multiple
marketplaces through natural language interaction. Users can describe
what they want in plain English, upload images or voice recordings, and
receive intelligent product recommendations aggregated from multiple
sources. Similarly, sellers can describe their items conversationally,
and the system automatically cross-posts listings to multiple
marketplaces with appropriate formatting.<br />
<br />
The platform leverages cutting-edge technologies including Large
Language Models (LLMs) for natural language understanding, state machine
orchestration for complex workflow management, and real-time WebSocket
communication for responsive user interactions. This project
demonstrates the practical application of AI in e-commerce, combining
multiple research areas including natural language processing,
distributed systems architecture, and human-computer interaction.</p>
<p><em>Figure 1.1: TalknShop System Architecture Block
Diagram</em><br />
<span id="_Toc215847398" class="anchor"></span><img
src="media/image1.jpg" style="width:6in;height:4.20833in"
alt="A diagram of a software system AI-generated content may be incorrect." /></p>
<h2 id="section-19"></h2>
<h2 id="section-20"></h2>
<h2 id="section-21"></h2>
<h2 id="section-22"></h2>
<h2 id="section-23"></h2>
<h2 id="proposed-areas-of-study-and-academic-contribution">Proposed
Areas of Study and Academic Contribution</h2>
<p>This project contributes to several areas of computer science and
software engineering:<br />
<br />
1. <strong>Conversational AI in E-Commerce:</strong> The project
explores how Large Language Models can be effectively integrated into
e-commerce platforms to understand user intent from natural language,
handle multi-modal inputs (text, voice, images), and generate structured
queries for product search. This addresses the research question of how
conversational interfaces can replace traditional keyword-based search
in complex, multi-vendor environments.<br />
<br />
2. <strong>State Machine Orchestration for Complex Workflows</strong>:
The project implements a sophisticated LangGraph-based state machine
that orchestrates multi-step workflows including media processing,
requirement extraction, clarification loops, and service coordination.
This contributes to the understanding of how state machines can manage
complex, conditional business logic in distributed systems.<br />
<br />
3. <strong>Real-Time Communication Patterns</strong>: The project
demonstrates production-ready WebSocket implementation for
bidirectional, real-time communication in AI-powered applications,
including connection management, heartbeat mechanisms, and streaming LLM
responses. This addresses scalability and reliability challenges in
real-time AI systems.<br />
<br />
4. <strong>Microservices Architecture for AI Systems</strong>: The
project implements a microservices architecture that separates concerns
between buyer (read-heavy) and seller (write-heavy) operations,
demonstrating how to design scalable systems that handle different
performance requirements and failure modes.<br />
<br />
5. <strong>Multi-Modal Input Processing:</strong> The project integrates
voice transcription, image analysis, and text processing to create a
unified understanding of user intent, contributing to research on
multi-modal AI systems in practical applications.<br />
<br />
<strong>Project Boundaries:</strong> This project focuses on the
orchestration layer and service architecture, implementing the buyer
flow (product search) as the primary use case. The seller flow
(cross-posting) is designed but implementation is deferred to future
work. The project does not include payment processing, order
fulfillment, or user authentication beyond basic session management.
Marketplace integrations are implemented for demonstration purposes
using public APIs where available.<br />
<br />
<strong>Academic Importance:</strong> This project is important because
it demonstrates how modern AI technologies can be practically applied to
solve real-world problems in e-commerce. It bridges the gap between
research in conversational AI and production system design, providing
insights into the challenges and solutions for building scalable,
reliable AI-powered applications. The project contributes to the growing
body of knowledge on LLM integration in production systems, state
machine patterns for workflow orchestration, and real-time communication
architectures.</p>
<h2 id="section-24"></h2>
<h2 id="current-state-of-the-art">Current State of the Art</h2>
<p>The current state of e-commerce platforms and conversational AI
systems reveals several trends and gaps:<br />
<br />
<strong>E-Commerce Platforms</strong>: Major platforms like Amazon,
eBay, and Walmart have sophisticated search capabilities but operate in
silos. Users must visit each platform separately, learn different
interfaces, and manually compare results. Price comparison sites like
Google Shopping aggregate results but still require keyword-based
queries and don't support conversational interaction.<br />
<br />
<strong>Conversational AI in Shopping</strong>: Virtual shopping
assistants exist (e.g., Amazon Alexa, Google Assistant shopping
features) but are typically limited to single-platform interactions and
simple queries. They lack the ability to search across multiple
marketplaces simultaneously or handle complex, multi-modal inputs
effectively.<br />
<br />
<strong>LLM Integration:</strong> Large Language Models like GPT-4,
Claude, and Gemini have demonstrated remarkable capabilities in natural
language understanding and generation. However, integrating these models
into production systems with complex workflows, state management, and
real-time requirements remains a challenge. Most implementations are
either simple chatbots or require extensive prompt engineering for
specific use cases.<br />
<br />
<strong>State Machine Orchestration:</strong> LangGraph and similar
frameworks provide powerful abstractions for building state machines
with LLMs, but production implementations with proper error handling,
checkpointing, and scalability are still emerging. The integration of
state machines with real-time communication and distributed services is
an active area of research.<br />
<br />
<strong>Multi-Modal AI:</strong> Vision-language models can analyze
images and generate descriptions, but integrating these capabilities
into end-to-end conversational systems with proper error handling and
fallback mechanisms is not well-documented in production contexts.<br />
<br />
<strong>Gap Addressed by TalknShop:</strong> TalknShop addresses the gap
between conversational AI research and production e-commerce systems
by:<br />
- Providing a unified interface across multiple marketplaces<br />
- Demonstrating practical LLM integration with state machine
orchestration<br />
- Implementing real-time, bidirectional communication for AI-powered
applications<br />
- Handling multi-modal inputs (text, voice, images) in a unified
workflow<br />
- Separating buyer and seller workflows to optimize for different
performance characteristics<br />
<br />
The project builds upon existing research in conversational AI, state
machine patterns, and microservices architecture, but combines these in
a novel way to address the specific challenges of multi-marketplace
e-commerce.</p>
<table style="width:99%;">
<colgroup>
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr>
<th>Platform</th>
<th>Search Method</th>
<th>Multi-Marketplace</th>
<th>Conversational AI</th>
</tr>
</thead>
<tbody>
<tr>
<td>Amazon</td>
<td>Keyword-based</td>
<td>No (single platform)</td>
<td>Limited (Alexa)</td>
</tr>
<tr>
<td>eBay</td>
<td>Keyword-based</td>
<td>No (single platform)</td>
<td>No</td>
</tr>
<tr>
<td>Google Shopping</td>
<td>Keyword-based</td>
<td>Yes (aggregation)</td>
<td>No</td>
</tr>
<tr>
<td>TalknShop</td>
<td>Natural language</td>
<td>Yes (unified)</td>
<td>Yes (full integration)</td>
</tr>
</tbody>
</table>
<p><strong>Table 1.1: Comparison of E-Commerce Platforms</strong><span
id="_Toc215847401" class="anchor"></span></p>
<h1 id="chapter-2.-project-architecture">Chapter 2. Project
Architecture</h1>
<h2 id="introduction-1">Introduction</h2>
<p>The TalknShop platform is built using a microservices architecture
that separates concerns between different functional areas. The system
is designed for scalability, reliability, and maintainability, following
industry best practices for distributed systems and AI
integration.<br />
<br />
The architecture consists of five main components:<br />
1. <strong>Orchestrator Service:</strong> Central coordination service
that manages WebSocket connections, executes LangGraph state machines,
and coordinates with downstream services<br />
2. <strong>Catalog Service:</strong> Handles product search across
multiple marketplaces for the buyer flow<br />
3. <strong>Seller Crosspost Service:</strong> Manages asynchronous
listing creation across multiple marketplaces for the seller flow<br />
4. <strong>Media Service:</strong> Processes audio transcription and
image analysis<br />
5. <strong>Client Applications:</strong> Web and iOS applications that
provide the user interface<br />
<br />
The system uses AWS services for infrastructure, including Bedrock for
LLM capabilities, DynamoDB for state persistence, SQS for asynchronous
job processing, and ECS Fargate for containerized service deployment.
Communication between services uses HTTP/REST for synchronous operations
and WebSocket for real-time client communication.<br />
<br />
The architecture follows several key design principles:<br />
- <strong>Service Separation:</strong> Buyer (read-heavy) and seller
(write-heavy) operations are separated into different services to
optimize for different performance characteristics<br />
- <strong>Asynchronous Processing:</strong> Long-running operations
(marketplace API calls) are handled asynchronously to avoid blocking
users<br />
- <strong>Failure Isolation:</strong> Issues in one service don't
cascade to others<br />
- <strong>Scalability:</strong> Each service can scale independently
based on load<br />
- <strong>State Management:</strong> Conversation state is persisted to
enable session resumption and debugging</p>
<p><strong>Table 2.1: Technology Stack by Service</strong></p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th><span id="_Toc215847402" class="anchor"></span>Service</th>
<th>Primary Technology</th>
<th>Supporting Technologies</th>
</tr>
</thead>
<tbody>
<tr>
<td>Orchestrator Service</td>
<td>FastAPI, WebSocket</td>
<td>LangGraph, AWS Bedrock, DynamoDB</td>
</tr>
<tr>
<td>Catalog Service</td>
<td>FastAPI</td>
<td>Marketplace APIs, Redis</td>
</tr>
<tr>
<td>Seller Crosspost Service</td>
<td>FastAPI, SQS</td>
<td>DynamoDB, Marketplace APIs</td>
</tr>
<tr>
<td>Media Service</td>
<td>FastAPI</td>
<td>AWS Bedrock, S3</td>
</tr>
<tr>
<td>Web Application</td>
<td>React, TypeScript</td>
<td>WebSocket, Tailwind CSS</td>
</tr>
</tbody>
</table>
<h2 id="section-25"></h2>
<h2 id="architecture-subsystems">Architecture Subsystems</h2>
<h3 id="orchestrator-service">2.1 Orchestrator Service</h3>
<p>The Orchestrator Service is the central nervous system of the
TalknShop platform, responsible for coordinating all user interactions
and workflow execution.<br />
<br />
<strong>Technology Stack</strong>: FastAPI, WebSocket, LangGraph, AWS
Bedrock (Claude 3 Sonnet), DynamoDB<br />
<br />
<strong>Key Responsibilities:<br />
</strong>- Manage WebSocket connections for real-time bidirectional
communication<br />
- Execute LangGraph state machines for buyer and seller workflows<br />
- Integrate with AWS Bedrock for LLM-powered decision making<br />
- Persist conversation state to DynamoDB<br />
- Coordinate with catalog-service and media-service<br />
- Stream LLM responses token-by-token to clients<br />
<br />
<strong>Architecture Components:</strong><br />
- WebSocket Manager: Handles connection lifecycle, heartbeat mechanism,
and message routing<br />
- LangGraph State Machine: 10-node buyer flow that processes user input,
extracts requirements, searches marketplaces, and composes
responses<br />
- AWS Bedrock Integration: Uses Claude 3 Sonnet for natural language
understanding, requirement extraction, and clarification question
generation<br />
- DynamoDB Repository: Persists session state, requirement
specifications, and search results<br />
- Service Clients: HTTP clients for communicating with catalog-service
and media-service with retry logic<br />
<br />
<strong>Workflow Execution:</strong> When a user sends a message, the
orchestrator:<br />
1. Parses the input and identifies media attachments<br />
2. Determines if media processing is needed (audio transcription, image
analysis)<br />
3. Extracts structured requirements from natural language using
LLM<br />
4. Determines if clarification is needed and asks questions if
necessary<br />
5. Searches marketplaces via catalog-service<br />
6. Ranks and composes results<br />
7. Streams responses back to the client<br />
<br />
Performance Characteristics: The orchestrator is designed to handle 1000
concurrent WebSocket connections, with workflow execution completing in
2-10 seconds (excluding marketplace search time).</p>
<h3 id="catalog-service-buyer-flow">2.2 Catalog Service (Buyer
Flow)</h3>
<p>The Catalog Service handles product search across multiple
marketplaces for the buyer workflow.<br />
<br />
<strong>Technology Stack:</strong> FastAPI, Marketplace APIs (eBay,
Amazon, Walmart, Best Buy)<br />
<br />
<strong>Key Responsibilities:<br />
</strong>- Execute product searches across multiple marketplaces in
parallel<br />
- Aggregate and normalize results from different marketplace APIs<br />
- Rank results by relevance, price, rating, and other factors<br />
- Return structured product data to the orchestrator<br />
<br />
<strong>Architecture Components:</strong><br />
- Search Adapters: Marketplace-specific adapters that translate
RequirementSpec to marketplace API queries<br />
- Aggregation Engine: Combines results from multiple marketplaces into a
unified format<br />
- Ranking Algorithm: Scores and ranks products based on multiple
criteria<br />
- Caching Layer: Redis-based caching for frequently searched
queries<br />
<br />
Supported Marketplaces: eBay, Amazon, Walmart, Best Buy (search
operations)<br />
<br />
<strong>Performance Characteristics:</strong> Synchronous operation with
1-3 second response time, designed to handle 100 searches per minute per
instance. The service scales horizontally to handle peak loads.</p>
<p>Figure 2.1: Buyer Flow State Machine Graph<br />
<img src="media/image2.jpg" style="width:6in;height:7.49028in"
alt="A diagram of a software company AI-generated content may be incorrect." /></p>
<h3 id="section-26"></h3>
<h3 id="section-27"></h3>
<h3 id="seller-crosspost-service-seller-flow">2.3 Seller Crosspost
Service (Seller Flow)</h3>
<p>The Seller Crosspost Service manages asynchronous listing creation
across multiple marketplaces.<br />
<br />
<strong>Technology Stack:</strong> FastAPI, Amazon SQS, DynamoDB,
Marketplace APIs<br />
<br />
<strong>Key Responsibilities:</strong><br />
- Validate listing requirements<br />
- Create SQS jobs for each target marketplace<br />
- Track job status in DynamoDB<br />
- Coordinate worker processes that execute marketplace API calls<br />
- Return job confirmation immediately and notify users when
complete<br />
<br />
<strong>Architecture Components:<br />
</strong>- Job Dispatcher: Creates SQS messages for each marketplace
posting operation<br />
- SQS Workers: Background workers that consume messages and execute
marketplace API calls<br />
- Job Tracker: DynamoDB-based tracking of job status across all
marketplaces<br />
- Posting Adapters: Marketplace-specific adapters that format listings
according to each platform's requirements<br />
<br />
<strong>Supported Marketplaces:</strong> eBay, Craigslist, Facebook
Marketplace, Poshmark (posting operations)<br />
<br />
<strong>Performance Characteristics:</strong> Asynchronous operation
with immediate job_id return (100ms), actual posting completes in 30
seconds to 5 minutes depending on marketplace API response times. The
service uses SQS for reliable job processing with automatic retries.</p>
<p>Figure 2.2: Seller Flow State Machine Graph<br />
<img src="media/image3.jpg" style="width:6in;height:7.41181in"
alt="A diagram of a software company AI-generated content may be incorrect." /></p>
<p><strong>2.4 Media Service</strong></p>
<p>The Media Service processes audio and image inputs for multi-modal
interaction.<br />
<br />
<strong>Technology Stack:</strong> FastAPI, AWS Bedrock (for vision and
speech), S3<br />
<br />
<strong>Key Responsibilities:</strong><br />
- Transcribe audio files to text using speech-to-text capabilities<br />
- Extract attributes from images using vision models<br />
- Store media files in S3<br />
- Return processed results to the orchestrator<br />
<br />
<strong>Architecture Components:</strong><br />
- Audio Transcription Module: Integrates with AWS Bedrock for
speech-to-text<br />
- Image Analysis Module: Uses vision-language models to extract product
attributes from images<br />
- S3 Storage: Manages media file storage and retrieval<br />
<br />
<strong>Performance Characteristics:</strong> Audio transcription
typically takes 2-5 seconds, image analysis takes 1-3 seconds. The
service is shared by both buyer and seller flows.</p>
<h3 id="client-applications">2.5 Client Applications</h3>
<p>Client applications provide the user interface for interacting with
the TalknShop platform.<br />
<br />
<strong>Web Application:<br />
</strong>- Technology: React, TypeScript, WebSocket, Tailwind CSS<br />
- Features: Chat interface, product card display, media upload,
real-time message streaming<br />
- Status: 90% complete with full WebSocket integration<br />
<br />
<strong>iOS Application:<br />
</strong>- Technology: Swift, URLSessionWebSocketTask<br />
- Features: Native iOS interface, voice input, image capture, push
notifications<br />
- Status: Planned for future implementation<br />
<br />
Both applications connect to the orchestrator service via WebSocket and
handle real-time bidirectional communication, including token-by-token
LLM response streaming.</p>
<h3 id="data-flow-and-communication-patterns">2.6 Data Flow and
Communication Patterns</h3>
<p>The system uses different communication patterns for different
operations:<br />
<br />
Real-Time Communication: WebSocket connections between clients and the
orchestrator service enable real-time bidirectional communication. The
orchestrator streams LLM responses token-by-token and sends progress
updates during workflow execution.<br />
<br />
Synchronous Service Calls: The orchestrator makes HTTP/REST calls to
catalog-service and media-service for synchronous operations like
product search and media processing. These calls use retry logic with
exponential backoff to handle transient failures.<br />
<br />
Asynchronous Job Processing: The seller flow uses Amazon SQS for
asynchronous job processing. When a user wants to post a listing, the
seller service creates SQS messages for each marketplace, returns a
job_id immediately, and workers process the jobs in the
background.<br />
<br />
State Persistence: Conversation state persisted to DynamoDB after each
workflow node execution, enabling session resumption and debugging.
State includes user messages, extracted requirements, search results,
and workflow progress.<br />
<br />
Error Handling: The system implements comprehensive error handling with
retry logic, graceful degradation (e.g., continuing workflow if media
processing fails), and user-friendly error messages sent via WebSocket
events.</p>
<p>Table 2.2: Buyer Flow Node Descriptions</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th>Node</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ParseInput</td>
<td>Tool</td>
<td>Load session, normalize message, extract metadata</td>
</tr>
<tr>
<td>NeedMediaOps</td>
<td>Agent/LLM</td>
<td>Decide if audio transcription or image processing needed</td>
</tr>
<tr>
<td>TranscribeAudio</td>
<td>Tool</td>
<td>Call media-service for speech-to-text</td>
</tr>
<tr>
<td>ExtractImageAttrs</td>
<td>Tool</td>
<td>Call media-service for image analysis</td>
</tr>
<tr>
<td>BuildRequirementSpec</td>
<td>Agent/LLM</td>
<td>Extract structured requirements from natural language</td>
</tr>
<tr>
<td>NeedClarify</td>
<td>Agent/LLM</td>
<td>Assess if requirement spec is sufficient for search</td>
</tr>
<tr>
<td>AskClarifyingQ</td>
<td>Agent/LLM</td>
<td>Generate contextual clarifying questions</td>
</tr>
<tr>
<td>SearchMarketplaces</td>
<td>Tool</td>
<td>Call catalog-service for product search</td>
</tr>
<tr>
<td>RankAndCompose</td>
<td>Tool</td>
<td>Rank results and compose response message</td>
</tr>
<tr>
<td>Done</td>
<td>Terminal</td>
<td>Mark workflow complete and return final response</td>
</tr>
</tbody>
</table>
<p>Table 2.3: Seller Flow Node Descriptions</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th>Node</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ParseInput</td>
<td>Tool</td>
<td>Load session, normalize message, extract metadata</td>
</tr>
<tr>
<td>NeedMediaOps</td>
<td>Agent/LLM</td>
<td>Decide if image processing needed for listing</td>
</tr>
<tr>
<td>TranscribeAudio</td>
<td>Tool</td>
<td>Call media-service for speech-to-text (if voice input)</td>
</tr>
<tr>
<td>ExtractImageAttrs</td>
<td>Tool</td>
<td>Call media-service for image analysis</td>
</tr>
<tr>
<td>BuildListingSpec</td>
<td>Agent/LLM</td>
<td>Extract structured listing from natural language</td>
</tr>
<tr>
<td>ValidateListingInputs</td>
<td>Tool</td>
<td>Validate listing requirements per marketplace</td>
</tr>
<tr>
<td>NeedClarify</td>
<td>Agent/LLM</td>
<td>Assess if listing spec is sufficient</td>
</tr>
<tr>
<td>AskClarifyingQ</td>
<td>Agent/LLM</td>
<td>Generate clarifying questions for missing info</td>
</tr>
<tr>
<td>CrosspostDispatch</td>
<td>Tool</td>
<td>Create SQS jobs for each target marketplace</td>
</tr>
<tr>
<td>ProcessMarketplaceJobs</td>
<td>Tool</td>
<td>Workers process SQS messages asynchronously</td>
</tr>
<tr>
<td>UpdateJobStatus</td>
<td>Tool</td>
<td>Update job status in DynamoDB as jobs complete</td>
</tr>
<tr>
<td>ComposeConfirmation</td>
<td>Tool</td>
<td>Generate confirmation message with listing links</td>
</tr>
</tbody>
</table>
<p>Table 2.4: Performance Characteristics by Service</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th>Service</th>
<th>Operation Type</th>
<th>Response Time</th>
<th>Throughput</th>
</tr>
</thead>
<tbody>
<tr>
<td>Orchestrator</td>
<td>WebSocket connection</td>
<td>&lt; 500ms</td>
<td>1000 concurrent</td>
</tr>
<tr>
<td>Orchestrator</td>
<td>Workflow execution</td>
<td>2-10s</td>
<td>100 concurrent</td>
</tr>
<tr>
<td>Catalog Service</td>
<td>Product search</td>
<td>1-3s</td>
<td>100 searches/min</td>
</tr>
<tr>
<td>Seller Service</td>
<td>Job creation</td>
<td>&lt; 100ms</td>
<td>50 jobs/min</td>
</tr>
<tr>
<td>Seller Service</td>
<td>Job processing</td>
<td>30s - 5min</td>
<td>Async via SQS</td>
</tr>
</tbody>
</table>
<h1 id="glossary">Glossary</h1>
<p><strong>LLM (Large Language Model):</strong> A type of artificial
intelligence model trained on vast amounts of text data to understand
and generate human-like text. TalknShop uses Claude 3 Sonnet via AWS
Bedrock.</p>
<p><strong>LangGraph:</strong> A framework for building state machines
with LLMs, enabling complex workflow orchestration with conditional
routing and state persistence.</p>
<p><strong>WebSocket:</strong> A communication protocol providing
full-duplex communication channels over a single TCP connection, used in
TalknShop for real-time bidirectional chat.</p>
<p><strong>State Machine:</strong> A computational model that defines a
set of states and transitions between states based on inputs. TalknShop
uses state machines to orchestrate buyer and seller workflows.</p>
<p><strong>RequirementSpec:</strong> A structured data model
representing product search requirements extracted from natural
language, including product type, price filters, and attributes.</p>
<p><strong>ListingSpec:</strong> A structured data model representing
product listing information for cross-posting to multiple marketplaces,
including title, price, condition, and images.</p>
<p><strong>DynamoDB:</strong> Amazon's NoSQL database service used in
TalknShop for session state persistence and job tracking.</p>
<p><strong>SQS (Simple Queue Service):</strong> Amazon's message queuing
service used in TalknShop for asynchronous processing of marketplace
posting jobs.</p>
<p><strong>AWS Bedrock:</strong> Amazon's managed service for accessing
foundation models, used in TalknShop for LLM inference with Claude 3
Sonnet.</p>
<p><strong>Microservices Architecture:</strong> An architectural
approach where applications are built as a collection of loosely
coupled, independently deployable services. TalknShop follows this
pattern with separate services for orchestrator, catalog, seller, and
media operations.</p>
<p><strong>Multi-Modal Input:</strong> The ability to process different
types of input (text, voice, images) in a unified manner. TalknShop
supports text messages, audio transcription, and image analysis.</p>
<p><strong>Cross-Posting:</strong> The process of posting a single
product listing to multiple marketplaces simultaneously. TalknShop
automates this for sellers.</p>
<p><strong>Orchestrator Service:</strong> The central coordination
service in TalknShop that manages WebSocket connections, executes
LangGraph workflows, and coordinates with downstream services.</p>
<p><strong>Catalog Service:</strong> The service responsible for product
search across multiple marketplaces in the buyer flow.</p>
<p><strong>Seller Crosspost Service:</strong> The service responsible
for asynchronous listing creation across multiple marketplaces in the
seller flow.</p>
<h1 id="references">References</h1>
<p>Anthropic. (2024). Claude 3 Sonnet Model Card. Anthropic AI.
Retrieved from <a
href="https://www.anthropic.com/claude">https://www.anthropic.com/claude</a></p>
<p>AWS. (2024). Amazon Bedrock Developer Guide. Amazon Web Services.
Retrieved from <a
href="https://docs.aws.amazon.com/bedrock/">https://docs.aws.amazon.com/bedrock/</a></p>
<p>AWS. (2024). Amazon DynamoDB Developer Guide. Amazon Web Services.
Retrieved from <a
href="https://docs.aws.amazon.com/amazondynamodb/">https://docs.aws.amazon.com/amazondynamodb/</a></p>
<p>LangChain. (2024). LangGraph Documentation. LangChain AI. Retrieved
from <a
href="https://langchain-ai.github.io/langgraph/">https://langchain-ai.github.io/langgraph/</a></p>
<p>FastAPI. (2024). FastAPI Documentation. FastAPI. Retrieved from <a
href="https://fastapi.tiangolo.com/">https://fastapi.tiangolo.com/</a></p>
<p>Richardson, L., &amp; Ruby, S. (2007). RESTful Web Services. O'Reilly
Media.</p>
<p>Newman, S. (2021). Building Microservices: Designing Fine-Grained
Systems (2nd ed.). O'Reilly Media.</p>
<p>Fowler, M. (2014). Microservices. Retrieved from <a
href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a></p>
<p>WebSocket API. (2024). The WebSocket API. MDN Web Docs. Retrieved
from <a
href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">https://developer.mozilla.org/en-US/docs/Web/API/WebSocket</a></p>
<p>React. (2024). React Documentation. Meta. Retrieved from <a
href="https://react.dev/">https://react.dev/</a></p>
<p>TypeScript. (2024). TypeScript Documentation. Microsoft. Retrieved
from <a
href="https://www.typescriptlang.org/docs/">https://www.typescriptlang.org/docs/</a></p>
<p>Pydantic. (2024). Pydantic Documentation. Pydantic. Retrieved from <a
href="https://docs.pydantic.dev/">https://docs.pydantic.dev/</a></p>
<h1 id="appendices">Appendices</h1>
<h2 id="appendix-a-description-of-implementation-repository">Appendix A:
Description of Implementation Repository</h2>
<p>The TalknShop project implementation is hosted in a Git repository
with the following structure:<br />
<br />
Repository Structure:<br />
- `apps/orchestrator-service/` - Central coordination service with
WebSocket and LangGraph implementation<br />
- `apps/catalog-service/` - Product search service for buyer flow<br />
- `apps/seller-crosspost-service/` - Asynchronous listing service for
seller flow<br />
- `apps/media-service/` - Audio transcription and image processing
service<br />
- `apps/talknshop-web/` - React-based web application<br />
- `infrastructure/cdk/` - AWS CDK infrastructure as code<br />
- `tools/documentation/` - Design documents and diagrams<br />
<br />
Key Implementation Files:<br />
- Orchestrator Service: `apps/orchestrator-service/main.py`,
`app/graph/graph.py`, `app/websocket/manager.py`<br />
- Service Clients: `app/services/catalog_client.py`,
`app/services/media_client.py`<br />
- Data Models: `app/models/schemas.py`, `app/models/enums.py`<br />
- Database: `app/db/dynamodb.py`<br />
- Configuration: `app/core/config.py`, `app/core/aws_clients.py`<br />
<br />
Technology Stack:<br />
- Backend: Python 3.11+, FastAPI, LangGraph, LangChain<br />
- Frontend: React, TypeScript, Tailwind CSS<br />
- Infrastructure: AWS (Bedrock, DynamoDB, SQS, ECS, S3)<br />
- Development: Docker, Docker Compose<br />
<br />
Documentation:<br />
- Architecture documentation: `ARCHITECTURE.md`<br />
- Design specifications:
`apps/orchestrator-service/Design-Specification.md`<br />
- Service READMEs: Individual service directories contain detailed
README files<br />
- Database documentation: `DATABASE_DOCUMENTATION.md`<br />
<br />
Repository Access:<br />
The repository is maintained as part of the SJSU Master's Project and
contains comprehensive documentation, code comments, and implementation
guides for all services.</p>
</body>
</html>
